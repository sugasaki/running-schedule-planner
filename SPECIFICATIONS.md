# ランニングスケジュールプランナー - 仕様書

## 概要
ランニングイベントのチェックポイント管理と時間計算を行うWebアプリケーション

## 主要機能

### 1. チェックポイント管理
- ドラッグ&ドロップによる行の順序変更
- チェックポイントの追加・編集・削除
- 場所名、区分（集合、スタート、ゴール等）の設定

### 2. 距離・間隔の自動計算システム

#### 2.1 基本仕様
- **距離列**: ユーザーが累積距離を入力（手動入力）
- **間隔列**: 前の行との距離差分を自動計算（読み取り専用）
- 計算式: `間隔[i] = 距離[i] - 距離[i-1]`

#### 2.2 自動再計算のタイミング
- **距離変更時**: 該当行および次の行の間隔を即座に再計算
- **ペース変更時**: 該当行から最終行までの時間計算を再実行
- **休憩時間変更時**: 該当行から最終行までの時間計算を再実行
- **行移動時**: 全ての行の間隔を即座に再計算
- **行追加/削除時**: 影響を受ける行の間隔を再計算

#### 2.3 データ検証とエラー表示システム

##### 2.3.1 エラー検出条件
- **距離逆転エラー**: 下の行の距離が上の行の距離より小さい場合

##### 2.3.2 エラー表示仕様
- **表示方法**: 該当行全体の背景色を赤色 (`#fee2e2`) に変更
- **複数エラー対応**: 複数行にエラーがある場合、すべての該当行を同時に赤色表示
- **エラー優先度**: エラー表示は区分別色分けより優先される

##### 2.3.3 エラーチェック実行タイミング
- **行移動後**: 全行を対象とした包括的チェック
- **距離編集後**: デバウンス処理（200ms）による最適化チェック
  - 連続した距離編集の最後の変更から200ms後に実行
  - パフォーマンス最適化とReact状態更新との競合回避

##### 2.3.4 IDベースの行識別システム
- **行移動対応**: データグリッドの表示順序とReact状態の不整合を解決
- **正確な更新**: IDを使用して正しいチェックポイントデータを特定・更新
- **データ整合性**: 行移動後も正確なエラーチェックと更新を保証

### 3. 時間計算システム

#### 3.1 計算ロジック
- スタート日時を基準に各チェックポイントの到着・出発時刻を算出
- 計算式: `移動時間 = 間隔 × ペース`
- 休憩時間を考慮した出発時刻の算出

#### 3.2 時刻表示形式
- 日付: `月/日` 形式
- 時刻: `時:分` 形式
- 日付をまたぐ長時間イベントに対応

### 4. プリセット管理

#### 4.1 プリセットカテゴリ
- `street-run`: 街ランコース
- `marathon`: マラソン・長距離イベント
- `training`: トレーニングプラン
- `custom`: ユーザーカスタム設定

#### 4.2 設定保存・読み込み
- JSON形式でのエクスポート・インポート
- LocalStorageによるカスタム設定の永続化

### 5. ユーザーインターフェース仕様

#### 5.1 グリッド操作

##### 5.1.1 行移動機能
- **移動方法**: 行番号をドラッグ&ドロップで移動
- **移動制限**: 最初の2行（集合・スタート）は移動不可
- **移動後処理**: 
  - Reactデータの順序をデータグリッドの表示順序に同期
  - 全行の距離エラーチェックを自動実行
  - 間隔と時刻の再計算を自動実行

##### 5.1.2 その他の操作
- **列移動**: 全ての列が移動可能
- **列幅調整**: 列境界のドラッグで調整可能
- **右クリックメニュー**: 行の追加・削除機能

#### 5.2 セルの背景色仕様
- **通常セル**: 白色 (`#ffffff`)
- **読み取り専用セル**: 薄いグレー (`#f9fafb`)
- **エラー行**: 薄い赤色 (`#fee2e2`)
- **エラー行**: 濃い赤色 (`#fecaca`)
- **区分別色分け**:
  - 集合: 薄い緑色 (`#f0fdf4`)
  - スタート: 薄い青色 (`#eff6ff`)
  - ゴール: 薄い黄色 (`#fefce8`)
  - トイレ: 薄いピンク(`#ffe5ec`)

#### 5.3 列定義
1. **場所**: チェックポイント名（テキスト入力）
2. **区分**: ドロップダウン選択（集合、スタート、トイレ、コンビニ、観光、休憩、ゴール、銭湯、打上げ）
3. **距離(km)**: 累積距離（数値入力、小数点2桁）
4. **ペース(分/km)**: 移動ペース（数値入力、小数点1桁）
5. **間隔(km)**: 区間距離（自動計算、読み取り専用）
6. **休憩(分)**: 休憩時間（数値入力、整数）
7. **日付**: 到着日付（自動計算、読み取り専用）
8. **到着**: 到着時刻（自動計算、読み取り専用）
9. **出発**: 出発時刻（自動計算、読み取り専用）

## 技術仕様

### 使用ライブラリ
- React 19 + TypeScript
- Handsontable (データグリッド実装 - 抽象化済み)
- Tailwind CSS (スタイリング)

### アーキテクチャ設計
- **レイヤード・アーキテクチャ**: 各層の責任を明確に分離
- **抽象化レイヤー**: データグリッドライブラリから独立したインターフェース
- **ライブラリ交換可能**: Handsontable以外のグリッドライブラリへの移行が容易

### 主要ファイル構成

#### アプリケーション層
- `RunningSchedulePlanner.tsx`: メインコンポーネント
- `DataGridSchedule.tsx`: 抽象化されたグリッドコンポーネント

#### ビジネスロジック層（ライブラリ非依存）
- `services/TableLogic.ts`: データ操作・検証・変換ロジック
- `services/GridSchema.ts`: 列定義・データ型・バリデーション規則
- `services/GridColumnConfig.ts`: 汎用列設定ファクトリー
- `services/GridConfig.ts`: グリッド初期化設定
- `services/GridStyles.ts`: 汎用スタイル定義

#### 抽象化層
- `components/grid/GridAdapter.ts`: データグリッド抽象インターフェース
- `components/grid/GridEventTranslator.ts`: ライブラリ非依存イベント変換

#### ライブラリ適合層（Handsontable固有）
- `components/grid/adapters/HandsontableUtils.ts`: Handsontable固有イベント処理
- `components/grid/adapters/HandsontableColumnAdapter.ts`: 列設定変換
- `components/grid/adapters/HandsontableStyles.ts`: Handsontable固有スタイル追加

#### フック・ユーティリティ
- `hooks/useTimeCalculations.ts`: 時間計算フック
- `services/ConfigManager.ts`: プリセット管理サービス
- `utils/timeCalculations.ts`: 時間計算ユーティリティ
- `utils/timeUtils.ts`: 時間フォーマットユーティリティ

### 開発・ビルドコマンド
```bash
# 開発サーバー起動
pnpm dev

# 型チェック（レイヤー間の依存関係チェック含む）
npx tsc -b

# ESLintチェック（アーキテクチャ規約チェック含む）
pnpm lint

# ビルド
pnpm build
```

### 開発ガイドライン

#### レイヤー間依存関係ルール
- **上位層は下位層のみに依存**: アプリケーション層 → ビジネスロジック層
- **下位層は上位層に依存禁止**: ビジネスロジック層 ← アプリケーション層
- **同一層内は相互依存禁止**: 適合層同士の依存は不可

#### コーディング規約
- **ビジネスロジック層**: UIライブラリのimport禁止
- **抽象化層**: 特定ライブラリ名の使用禁止
- **適合層**: 担当ライブラリ以外への依存禁止

## 制約事項

### データ制約
- **距離順序**: 距離は前の行以上の値である必要がある
- **保護行**: 最初の2行（集合・スタート）は削除・移動不可
- **読み取り専用列**: 間隔列、計算結果列（日付、到着、出発）は直接編集不可

### パフォーマンス制約
- **デバウンス処理**: 距離編集後のエラーチェックは200ms遅延
- **全行チェック**: 行移動時は全行を対象とした処理実行
- **レイヤー間通信**: 最小限のデータ変換でオーバーヘッドを削減
- **メモ化**: 重い計算処理は適切にキャッシュ

### 技術制約
- **IDベース管理**: チェックポイントの識別と更新はID基準
- **状態同期**: データグリッドの表示状態とReact状態の分離管理
- **ライブラリ抽象化**: 特定のデータグリッドライブラリに依存しない設計

## アーキテクチャ詳細

### 1. レイヤー構成

#### 1.1 アプリケーション層
- **役割**: ユーザーインターフェースとユーザー操作の処理
- **技術**: React コンポーネント、カスタムフック
- **依存関係**: ビジネスロジック層のみに依存

#### 1.2 ビジネスロジック層
- **役割**: アプリケーションの核となる処理・ルール・データ変換
- **技術**: 純粋なTypeScript クラス・関数
- **特徴**: UI技術・ライブラリから完全独立

#### 1.3 抽象化層
- **役割**: データグリッドライブラリの差異を吸収
- **技術**: インターフェース定義・イベント変換
- **特徴**: 複数のライブラリに対応可能な汎用設計

#### 1.4 ライブラリ適合層
- **役割**: 特定ライブラリのAPI実装
- **技術**: ライブラリ固有のアダプター・変換
- **特徴**: ライブラリ変更時のみ更新が必要

### 2. 抽象化の利点

#### 2.1 ライブラリ交換容易性
- **現在**: Handsontable使用
- **移行例**: AG-Grid、React Table、@tanstack/table等
- **移行コスト**: 適合層のみの更新で完了

#### 2.2 テスト容易性
- **単体テスト**: ビジネスロジックをUI非依存でテスト
- **統合テスト**: 抽象化層でのモック・スタブ作成が容易
- **E2Eテスト**: UI変更の影響を最小化

#### 2.3 保守性向上
- **責任分離**: 各層の役割が明確
- **変更影響**: 局所的な変更で済む
- **新機能追加**: 適切な層への追加で既存コードの影響を最小化

### 3. 設計パターン

#### 3.1 Adapter パターン
- **目的**: ライブラリ固有APIを汎用インターフェースに変換
- **実装**: HandsontableColumnAdapter、GridEventTranslator

#### 3.2 Factory パターン
- **目的**: 設定オブジェクトの生成を一元化
- **実装**: GridColumnConfigFactory、DefaultGridConfig

#### 3.3 Strategy パターン
- **目的**: データグリッドライブラリの切り替えを可能にする
- **実装**: IDataGridAdapter インターフェース

### 4. 拡張性

#### 4.1 新しいデータグリッドライブラリの追加
1. `components/grid/adapters/[NewLibrary]*.ts` ファイル作成
2. `IDataGridAdapter` インターフェース実装
3. `DataGridSchedule.tsx` のimport変更
4. ビジネスロジック・設定は変更不要

#### 4.2 新しい列タイプの追加
1. `GridSchema.ts` で新しい列定義
2. `GridColumnConfig.ts` で設定追加
3. 各アダプターで新しいタイプのマッピング追加

#### 4.3 新しいチェックポイント種別の追加
1. `GridSchema.ts` の `CHECKPOINT_TYPES` に追加
2. スタイル定義の追加（必要に応じて）
3. ビジネスロジックは自動的に対応